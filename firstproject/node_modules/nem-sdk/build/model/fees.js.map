{"version":3,"sources":["../../src/model/fees.js"],"names":["baseTransactionFee","currentFeeFactor","multisigTransaction","Math","floor","rootProvisionNamespaceTransaction","subProvisionNamespaceTransaction","mosaicDefinitionTransaction","namespaceAndMosaicCommon","signatureTransaction","importanceTransferTransaction","multisigAggregateModificationTransaction","calculateMessage","message","isHW","payload","length","type","ceil","calculateMosaics","multiplier","mosaics","attachedMosaics","totalFee","fee","supplyRelatedAdjustment","i","m","mosaicName","mosaicIdToName","mosaicId","mosaicDefinitionMetaDataPair","divisibilityProperties","grep","mosaicDefinition","properties","w","name","divisibility","value","supply","quantity","maxMosaicQuantity","totalMosaicQuantity","pow","log","numNem","calculateXemEquivalent","calculateMinimum","max","q","sup","module","exports"],"mappings":"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","file":"fees.js","sourcesContent":["import Helpers from '../utils/helpers';\nimport Format from '../utils/format';\n\n/**\n * The Fee structure's base fee\n *\n * @type {number}\n */\nconst baseTransactionFee = 3;\n\n/**\n * The Fee structure's Fee factor\n *\n * @type {number}\n */\nconst currentFeeFactor = 0.05;\n\n/**\n * The multisignature transaction fee\n *\n * @type {number}\n */\nconst multisigTransaction = Math.floor((baseTransactionFee * currentFeeFactor) * 1000000);\n\n/**\n * The provision namespace transaction rental fee for root namespace\n *\n * @type {number}\n */\nconst rootProvisionNamespaceTransaction = 100 * 1000000;\n\n/**\n * The provision namespace transaction rental fee for sub-namespace\n *\n * @type {number}\n */\nconst subProvisionNamespaceTransaction = 10 * 1000000;\n\n/**\n * The mosaic definition transaction fee\n *\n * @type {number}\n */\nconst mosaicDefinitionTransaction = 10 * 1000000;\n\n/**\n * The common transaction fee for namespaces and mosaics\n *\n * @type {number}\n */\nconst namespaceAndMosaicCommon = Math.floor((baseTransactionFee * currentFeeFactor) * 1000000);\n\n/**\n * The cosignature transaction fee\n *\n * @type {number}\n */\nconst signatureTransaction = Math.floor((baseTransactionFee * currentFeeFactor) * 1000000);\n\n\n/**\n * The importance transfer transaction fee\n *\n * @type {number}\n */\nconst importanceTransferTransaction = Math.floor((baseTransactionFee * currentFeeFactor) * 1000000);\n\n/**\n * The multisignature aggregate modification transaction fee\n *\n * @type {number}\n */\nconst multisigAggregateModificationTransaction = Math.floor((10 * currentFeeFactor) * 1000000);\n\n\n/**\n * Calculate message fee. 0.05 XEM per commenced 32 bytes\n *\n * If the message is empty, the fee will be 0\n *\n * @param {object} message - An message object\n * @param {boolean} isHW - True if hardware wallet, false otherwise\n *\n * @return {number} - The message fee\n */\nlet calculateMessage = function(message, isHW) {\n\n    if (!message.payload || !message.payload.length)\n        return 0.00;\n\n    let length = message.payload.length / 2;\n\n    // Add salt and IV and round up to AES block size\n    if (isHW && message.type == 2)\n        length = 32 + 16 + Math.ceil(length / 16) * 16;\n\n    return currentFeeFactor * (Math.floor(length / 32) + 1);\n}\n\n/**\n * Calculate fees for mosaics included in a transfer transaction\n *\n * @param {number} multiplier - A quantity multiplier\n * @param {object} mosaics - A mosaicDefinitionMetaDataPair object\n * @param {array} attachedMosaics - An array of mosaics to send\n *\n * @return {number} - The fee amount for the mosaics in the transaction\n */\nlet calculateMosaics = function(multiplier, mosaics, attachedMosaics) {\n    let totalFee = 0;\n    let fee = 0;\n    let supplyRelatedAdjustment = 0;\n    for (let i = 0; i < attachedMosaics.length; i++) {\n        let m = attachedMosaics[i];\n        let mosaicName = Format.mosaicIdToName(m.mosaicId);\n        if (!(mosaicName in mosaics)) {\n            return ['unknown mosaic divisibility']; //\n        }\n        let mosaicDefinitionMetaDataPair = mosaics[mosaicName];\n        let divisibilityProperties = Helpers.grep(mosaicDefinitionMetaDataPair.mosaicDefinition.properties, function(w) {\n            return w.name === \"divisibility\";\n        });\n        let divisibility = divisibilityProperties.length === 1 ? ~~(divisibilityProperties[0].value) : 0;\n        let supply = mosaicDefinitionMetaDataPair.supply; //\n        let quantity = m.quantity;\n        if (supply <= 10000 && divisibility === 0) {\n            // Small business mosaic fee\n            fee = currentFeeFactor;\n        } else {\n            let maxMosaicQuantity = 9000000000000000;\n            let totalMosaicQuantity = supply * Math.pow(10, divisibility)\n            supplyRelatedAdjustment = Math.floor(0.8 * Math.log(maxMosaicQuantity / totalMosaicQuantity));\n            let numNem = calculateXemEquivalent(multiplier, quantity, supply, divisibility);\n            // Using Math.ceil below because xem equivalent returned is sometimes a bit lower than it should\n            // Ex: 150'000 of nem:xem gives 149999.99999999997\n            fee = calculateMinimum(Math.ceil(numNem));\n        }\n        totalFee += currentFeeFactor * Math.max(1, fee - supplyRelatedAdjustment);\n    }\n    return totalFee;\n}\n\n/**\n * Calculate fees from an amount of XEM\n *\n * @param {number} numNem - An amount of XEM\n *\n * @return {number} - The minimum fee\n */\nlet calculateMinimum = function(numNem) {\n    let fee = Math.floor(Math.max(1, numNem / 10000));\n    return fee > 25 ? 25 : fee;\n}\n\n/**\n * Calculate mosaic quantity equivalent in XEM\n *\n * @param {number} multiplier - A mosaic multiplier\n * @param {number} q - A mosaic quantity\n * @param {number} sup - A mosaic supply\n * @param {number} divisibility - A mosaic divisibility\n *\n * @return {number} - The XEM equivalent of a mosaic quantity\n */\nlet calculateXemEquivalent = function(multiplier, q, sup, divisibility) {\n    if (sup === 0) {\n        return 0;\n    }\n    // TODO: can this go out of JS (2^54) bounds? (possible BUG)\n    return 8999999999 * q * multiplier / sup / Math.pow(10, divisibility + 6);\n}\n\nmodule.exports = {\n    multisigTransaction,\n    rootProvisionNamespaceTransaction,\n    subProvisionNamespaceTransaction,\n    mosaicDefinitionTransaction,\n    namespaceAndMosaicCommon,\n    signatureTransaction,\n    calculateMosaics,\n    calculateMinimum,\n    calculateMessage,\n    calculateXemEquivalent,\n    currentFeeFactor,\n    importanceTransferTransaction,\n    multisigAggregateModificationTransaction\n}"]}